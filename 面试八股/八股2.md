## 2.1 硬件基础

### 2.1.1 NAND FLASH 和NOR FLASH异同？

我们使用的智能手机除了有一个可用的空间（如苹果8G、16G等），还有一个RAM容量，很多人都不是很清楚，为什么需要2个这样的芯片做存储呢，这就是我们下面要讲到的。这2种存储设备我们都统称为“FLASH”，FLASH是一种存储芯片，全名叫Flash EEPROM emory，通地过程序可以修改数据，即平时所说的“闪存”。Flash又分为NAND flash和NOR flash二种。

许多业内人士也搞不清楚NAND闪存技术相对于NOR技术的优越之处，因为大多数情况下闪存只是用来存储少量的代码，这时NOR闪存更适合一些。而NAND则是高数据存储密度的理想解决方案。NOR Flash 的读取和我们常见的 SDRAM 的读取是一样，用户可以直接运行装载在 NOR Flash里面的代码，这样可以减少 SRAM 的容量从而节约了成本。 NAND Flash 没有采取内存的随机读取技术，它的读取是以一次读取一块的形式来进行的， 通常是一次读取 512 个字节，采用这种技术的 Flash 比较廉价。用户不能直接运行NAND Flash 上的代码，因此好多使用 NAND Flash 的开发板除了使用NAND Flash以外，还用了 一块小的 NOR Flash 来运行启动代码。
NOR flash是intel公司1988年开发出了NOR flash技术。NOR的特点是芯片内执行（XIP, eXecute In Place），这样应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。NOR的传输效率很高，在1～4MB的小容量时具有很高的成本效益，但是很低的写入和擦除 速度大大影响了它的性能。

**不同点：**

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723794366231/D2B5CA33BD970F64A6301FA75AE2EB22)

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723794386458/D2B5CA33BD970F64A6301FA75AE2EB22)

**注意：nandflash 和 norflash 的 0 地址是不冲突的，norflash 占用 BANK 地址，而 nandflash不占用 BANK 地址，它的 0 地址是内部的。**

**相同点：**

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723794453032/D2B5CA33BD970F64A6301FA75AE2EB22)

### 2.1.2 CPU、MPU、MCU、SOC、SOPC 联系与差别？

1. CPU（Central Processing Unit）,是一台计算机的运算核心和控制核心。CPU由运算器、控制器和寄存器及实现它们之间联系的数据、控制及状态的总线构成。差不多所有的CPU的运作原理可分为四个阶 段：提取（Fetch）、解码（Decode）、执行（Execute）和写回（Writeback）。 CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，并执行指令。所谓的计算机的可编程性主要是指对CPU的编程。
2. MPU (Micro Processor Unit)，叫微处理器（不是微控制器），通常代表一个功能强大的CPU（暂且 理解为增强版的CPU吧）,但不是为任何已有的特定计算目的而设计的芯片。这种芯片往往是个人计算机和高端工作站的核心CPU。最常见的微处理器是Motorola的68K系列和Intel的X86系列。
3. MCU(Micro Control Unit)，叫微控制器，是指随着大规模集成电路的出现及其发展，将计算机的 CPU、RAM、ROM、定时计数器和多种I/O接口集成在一片芯片上，形成芯片级的芯片，比如51，avr这些芯片，内部除了CPU外还有RAM,ROM,可以直接加简单的外围器件（电阻，电容）就可以运行代码 了，而MPU如x86，arm这些就不能直接放代码了，它只不过是增强版的CPU，所以得添加RAM,ROM。 MCU MPU 最主要的区别就是能否直接运行代码。MCU有内部的RAM ROM，而MPU是增强版的CPU，需要添加外部RAM ROM才可以运行代码。
4. SOC（System on Chip），指的是片上系统，MCU只是芯片级的芯片，而SOC是系统级的芯片，它既MCU（51，avr）那样有内置RAM,ROM同时又像MPU（arm）那样强大的，不单单是放简单的代码，可以放系统级的代码，也就是说可以运行操作系统（将就认为是MCU集成化与MPU强处理力各优点二合一）。
5. SOPC（System On a Programmable Chip）可编程片上系统（FPGA就是其中一种），上面4点的硬 件配置是固化的，就是说51单片机就是51单片机，不能变为avr，而avr就是avr不是51单片机，他们的硬件是一次性掩膜成型的，能改的就是软件配置，说白点就是改代码，本来是跑流水灯的，改下代码，变成数码管，而SOPC则是硬件配置，软件配置都可以修改，软件配置跟上面一样，没什么好说的，至于硬件，是可以自己构建的也就是说这个芯片是自己构造出来的，这颗芯片我们叫“白片”，什么芯片都不是，把硬件配置信息下载进去了，他就是相应的芯片了，可以让他变成51，也可以是avr，甚至arm，同时SOPC是在SOC基础上来的，所以他也是系统级的芯片，所以记得当把他变成arm时还得加外围ROM，RAM之类的，不然就是MPU了。

### 2.1.3 什么是交叉编译？

       在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码，我们就称这种编译器支持交叉编译。这个编译过程就叫交叉编译。简单地说，就是在一个平台上生成另一个平台上的可执行代码。

      这里需要注意的是所谓平台，实际上包含两个概念：体系结构（Architecture）、操作系统（OperatingSystem）。同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和Windows NT for x86操作系统的简称。

### 2.1.4  为什么需要交叉编译？

       有时是因为目的平台上不允许或不能够安装我们所需要的编译器，而我们又需要这个编译器的某些特征；有时是因为目的平台上的资源贫乏，无法运行我们所需要编译器；有时又是因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器。

### 2.1.5 ROM和RAM的区别及类型

**页（Page）< 扇区（Sector） < 块（Block）< 芯片（Chip）**

一般1页是1k

ROM为只读存储器，RAM为读写存储器。

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723794746669/D2B5CA33BD970F64A6301FA75AE2EB22)

存储器按其存储介质特性主要分为“易失性存储器”和“非易失性存储器”两大类。

其中的“易失/非易失”是指存储器断电后，它存储的数据内容是否会丢失的特性。由于一般易失性存储器存取速度快，而非易失性存储器可长期保存数据，它们都在计算机中占据着重要角色。

在计算机中易失性存储器最典型的代表是内存，非易失性存储器的代表则是硬盘。

**关于RAM中，DRAM和SRAM对比：**

       DRAM中代表1的电容会放电，因此需要定时刷新，刷新操作会对电容电量进行检查。而DRAM本身分为同步和异步两种通讯方式，其中同步通讯方式速度更快，应用广泛，同步通讯的方式叫做SDRAM。

       SRAM利用锁存器去存储数据，不需要定时刷新充电。所以被称为静态RAM，（static RAM）。而SRAM本身也分为同步和异步通讯，相对而言，异步SRAM用的比较广泛。

          对比 DRAM 与 SRAM 的结构，可知 DRAM 的结构简单得多，所以生产相同容量的存储器，DRAM的成本要更低，且集成度更高。而 DRAM 中的电容结构则决定了它的存取速度不如 SRAM，特性对比见表 DRAM 与 SRAM 对比。

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723794777072/D2B5CA33BD970F64A6301FA75AE2EB22)

所以在实际应用场合中，SRAM 一般只用于 CPU 内部的高速缓存 (Cache)，而外部扩展的内存一般使用 DRAM。在 STM32 系统的控制器中，只有STM32F429 型号或更高级的芯片才支持扩展SDRAM，其它型号如STM32F1、STM32F2 及 STM32F407 等型号只能扩展 SRAM。

关于ROM中：

       ROM中应用最广泛的是EEPROM。它可重复擦写，擦除和写入都是直接用外部设备来擦写，而且可以按字节为单位修改数据。

关于FLASH：

       FLASH 存储器又称 为闪存，它也是可重复擦写的储器，部分书籍会把FLASH 存储器称为 FLASH ROM，但它的容量一般比 EEPROM 大得多，且在擦除时，一般以多个字节为单位。如有的 FLASH 存储器以 4096 个字节为扇区，最小的擦除单位为一个扇区。

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723794814129/D2B5CA33BD970F64A6301FA75AE2EB22)

NOR 与 NAND 的共性是在数据写入前都需要有擦除操作，而擦除操作一般是以“扇区/块”为单位的。

       而 NOR 与 NAND 特性的差别，主要是由于其内部“地址/数据线”是否分开导致的。

       由于 NOR 的地址线和数据线分开，它可以按“字节”读写数据；而由于 NAND 的数据和地址线共用，只能按“块”来读写数据。

       由于两种 FLASH 存储器特性的差异，NOR FLASH 一般应用在代码存储的场合，如嵌入式控制器内部的程序存储空间。而 NAND FLASH 一般应用在大数据量存储的场合，包括 SD 卡、U盘以及固态硬盘等，都是 NAND FLASH 类型的。

### 2.1.6 Cortex-M3寄存器组

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723794880947/D2B5CA33BD970F64A6301FA75AE2EB22)

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723794894090/D2B5CA33BD970F64A6301FA75AE2EB22)

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723794909071/D2B5CA33BD970F64A6301FA75AE2EB22)

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723794920137/D2B5CA33BD970F64A6301FA75AE2EB22)

### 2.1.7 保存、恢复现场的详细操作

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723794959807/D2B5CA33BD970F64A6301FA75AE2EB22)

**向量表**从FLASH的0地址开始放置，以4个字节为一个单位，地址0存放的是栈顶地址，0X04存放的是复位程序的地址，以此类推。从代码上看，向量表中存放的都是中断服务函数的函数名，可我们知道C语言中的函数名就是一个地址

首先是中断或异常产生，CPU去FLASH里面找对应的异常向量表，异常向量表找到对应的中断函数，执行中断函数前，要进行保护现场的操作，中断函数结束后，恢复现场。

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723795007861/D2B5CA33BD970F64A6301FA75AE2EB22)

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723795024414/D2B5CA33BD970F64A6301FA75AE2EB22)

寄存器R13在ARM指令中常用作堆栈指针SP,但这只是一种习惯用法，用户也可使用其他的寄存器作为堆栈指针,而在Thumb指令集中,某些指令强制性的要求使用R13作为堆栈指针.

        由于处理器的每种运行模式均有自己独立的物理寄存器R13，在用户应用程序的初始化部分，一般都要初始化每种模式下的R13，使其指向该运行模式的栈空间。这样，当程序的运行进入异常模式时，可以将需要保护的寄存器放入R13所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈中恢复，采用这种方式可以保证异常发生后程序的正常执行。

        R14称为子程序链接寄存器LR(Link Register),当执行子程序调用指令(BL)时,R14可得到R15(程序计数器PC)的备份。

        保护现场：首先，将SP的值保存在IP寄存器中（此时IP中存的sp是未进行压栈的sp），然后让fp ip lr pc按照从右向左顺序入栈，入栈的过程中，让sp随着入栈而不断增长。入栈过程中，sp不断增加，从左图高地址处sp一直移动到fp处，然后将ip-4，将sp存入fp中（相当于fp中存的是pc当前地址）。此时，fp里面存入了栈顶sp。

       恢复现场：先将fp-12，此时fp内存的地址即为当前sp所在位置，然后将fp赋值给fp，sp赋值给ip，lr赋值给pc。其中lr为函数返回地址，而pc存储的是程序要执行的下一条指令。

### 2.1.8 单片机启动流程

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723795069278/D2B5CA33BD970F64A6301FA75AE2EB22)

#### **2.1.8.1 单片机基础**

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723795098433/D2B5CA33BD970F64A6301FA75AE2EB22)

从图中看出，代码一般存储在ROM区，然后一些局部变量等利用SRAM来进行存储。

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723795122057/D2B5CA33BD970F64A6301FA75AE2EB22)

#### **2.1.8.2 启动流程**

单片机上电后一直到准备好C语言运行环境并跳转到main函数执行总共经历了5个步骤：

1.内核初始化;

2.强制PC指针指向中断向量表的复位中断向量执行复位中断函数;

3.在复位中断函数中调用 SystemInit 函数，初始化时钟，配置中断向量表等

4.调用 __main 函数完成全局/静态变量/常量的初始化和重定位工作，初始化堆栈和库函数

5.跳转到main函数中执行

**注意：**

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723795189300/D2B5CA33BD970F64A6301FA75AE2EB22)

#### ​ **2.1.8.3 重定位**

PC指针：**pc指针是指寄存器pc，里边的值总是指向当前程序运行点的地址。**

SP指针：SP指针指堆栈指针，也是通用寄存器，用于入栈和出栈操作。

## 2.1 硬件基础

### 2.1.9 异常和中断

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723795590404/D2B5CA33BD970F64A6301FA75AE2EB22)

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723795602849/D2B5CA33BD970F64A6301FA75AE2EB22)

 在处理器执行到因编译 错误而导致的错误指令时，或者在执行期间出现特殊错误，必须靠内核处理的时候，处理器就会产生一个异常。

### 2.1.10 中断和DMA的区别

DMA：是一种无须CPU的参与，就可以让外设与系统内存之间进行双向数据传输的硬件机制，使用 DMA可以使系统CPU从实际的I/O数据传输过程中摆脱出来，从而大大提高系统的吞吐率。

中断：是指CPU在执行程序的过程中，出现了某些突发事件时，CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后CPU又返回源程序被中断的位置并继续执行。

所以中断和DMA的区别就是：**DMA不需CPU参与，而中断是需要CPU参与的**。

### 2.1.11  H中断能不能睡眠，为什么？下半部能不能睡眠？

### 2.1.12 中断响应执行流程
中断的响应流程：cpu接受中断->保存中断上下文跳转到中断处理历程->执行中断上半部->执行中断下半部->恢复中断上下文。

### 2.1.13 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？
中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。
凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求 cpu的频率比较低，则用中断效率要高一些。主要是看请求频率。

### 2.1.14 当一个异常出现以后，ARM微处理器会执行哪几步操作？

1. 将下一条指令的地址存入相应连接寄存器LR，以便程序在处理异常返回时能从正确的位置重新开始执行。若异常是从ARM状态进入，则LR寄存器中保存的是下一条指令的地址（当前PC＋4或PC＋ 8，与异常的类型有关）；若异常是从Thumb状态进入，则在LR寄存器中保存当前PC的偏移量，这样，异常处理程序就不需要确定异常是从何种状态进入的。例如：在软件中断异常SWI，指令 MOV PC，R14_svc总是返回到下一条指令，不管SWI是在ARM状态执行，还是在Thumb状态执行。

2. 将CPSR复制到相应的SPSR中。

3. 根据异常类型，强制设置CPSR的运行模式位。

4. 强制PC从相关的异常向量地址取下一条指令执行，从而跳转到相应的异常处理程序处

**注意：**

CPSR: 程序状态寄存器(当前程序状态寄存器)，在任何处理器模式下被访问

SPSR：程序状态保存寄存器（saved programstatus register）,每一种处理器模式下都有一个状态寄存器SPSR,SPSR用于保存CPSR的状态，以便异常返回后恢复异常发生时的工作状态

### 2.1.15 ARM内核架构

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723795674948/D2B5CA33BD970F64A6301FA75AE2EB22)

**1. ICode总线：**ICode 中的 I 表示 Instruction，即指令。我们写好的程序编译之后都是一条条指令，存放在 FLASH 中，内核要读取这些指令来执行程序就必须通过 ICode 总线，它几乎每时每刻 都需要被使用，它是专门用来取指的。

**2、DCode总线**：DCode 中的 D 表示 Data，即数据，那说明这条总线是用来取数的。我们在写程序的时候，数据有常量和变量两种，常量就是固定不变的，用 C 语言中的 const 关键字修饰，是放到内部的 FLASH 当中的，变量是可变的，不管是全局变量还是局部变量都放在内部的 SRAM。因为数据可以被 Dcode 总线和 DMA 总线访问，所以为了避免访问冲突，在取数的时候需要经过一个总线矩阵来仲裁，决定哪个总线在取数。

**3、系统总线：** 系统总线主要是访问外设的寄存器，我们通常说的寄存器编程，即读写寄存器都是通 过这根系统总线来完成的

（1）FSMC的英文全称是 Flexible static memory controller，叫灵活的静态的存储器控制器， 是 STM32F10xx 中一个很有特色的外设，通过 FSMC，我们可以扩展内存，如外部的 SRAM，NANDFLASH 和 NORFLASH。

（2）内部的闪存存储器即 FLASH，我们编写好的程序就放在这个地方。内核通过 ICode 总 线来取里面的指令。

（3）DMA总线（Direct Memory Access)即直接存储器访问。主要用来传输数据，这个数据可以是某个外设的数据寄存存器，可以在SRAM，可以在内部的FLASH。

（4）AHB到APB的桥。AHB（Advanced High performance Bus）系统总线高级高性能总线

APB(Advance Peripheral BUS)外围总线。

（5）看门狗模块（watchdog timer）：定期查看芯片内部的情况，一旦发生错误向芯片发出重启信号。看门狗命令在程序的中断中拥有最高的优先级。

### ​2.1.16 STM32是大端还是小端？
STM32是小端模式

### 2.1.17 Linux系统启动流程？

#### 2.1.17.1 执行ROM代码

它是处理器上电以后首先执行的程序，ROM代码的主要工作就是读取 STM32MP1的BOOT引脚电平，然后根据电平判断当前启动设备，最后从选定的启动设备里面读取FSBL代码，并将FSBL代码放到对应的RAM空间。（first stage boot loader 第一阶段加载程序）

#### 2.1.17.2 FSBL
FSBL 代码初始化时钟树、初始化外部RAM控制器，也就是DDR。最终FSBL将SSBL加载到DDR里面并运行SSBL代码。

DDR的全称其实是DDR SDRAM。所以在介绍DDR之前，得先了解什么是SDRAM。

SDRAM（同步动态随机存取内）可以看作一种特殊的DRAM（动态随机存取内存），我们平时说的计算机内存条就是一种DRAM。
SDRAM除了异步接口，还多了一个同步接口。同步接口需要数据发送方和接收方有一个统一的时钟信号，技术相对复杂，相应的传输速率和并发度都更高。

#### 2.1.17.3 SSBL

由于SSBL代码运行在DDR里面，无需担心空间不够，因此SSBL代码的功能就可以做的 很全面，比如使能USB、网络、显示等等。这样我们就可以在SSBL中灵活的加载linux内核， 比如从Flash设备上读取，或者通过网络下载下载等，用户使用起来也非常的友好。SSBL一般是Uboot，用来启动Linux内核。

#### 2.1.17.4 Linux内核
SSBL 部分的Uboot就一个使命，启动Linux内核，Uboot会将Linux内核加载到DDR上 并运行。Linux内核启动过程中会初始化板子上的各种外设。​

#### 2.1.17.5 Linux用户空间
系统启动的时候会通过init 进程切换到用户空间，在这个过程中会初始化根文件系统里面 的各种框架以及服务。

# 3. ARM

## 2.2 通讯协议：

**不同双工通讯：**

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723795960829/D2B5CA33BD970F64A6301FA75AE2EB22)

**同步/异步通讯：**
时钟线，有时钟线那就是同步通信，否则就是异步通信。

### 2.2.1 串口通讯协议总结

#### 2.2.1.1 RS232物理层

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796008890/D2B5CA33BD970F64A6301FA75AE2EB22)

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796022438/D2B5CA33BD970F64A6301FA75AE2EB22)

其中RS-232提高电压后，增加了串口通信的远距离传输能力和抗干扰能力。

#### 2.2.1.2 RS485物理层

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796050669/D2B5CA33BD970F64A6301FA75AE2EB22)

RS-485 通讯网络的最大传输距离可达 1200 米，总线上可挂载 128 个通讯节点，而由于 RS-485 网络只有一对差分信号线，它使用差分信号来表达逻辑，当 AB 两线间的电压差为-6V~-2V 时表示逻辑 1，当电压差为 +2V~+6V 表示逻辑 0，在同一时刻只能表达一个信号，所以它的通讯是半双工形式的。

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796076326/D2B5CA33BD970F64A6301FA75AE2EB22)

#### 2.2.1.3 串口通讯协议

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796100360/D2B5CA33BD970F64A6301FA75AE2EB22)

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796107419/D2B5CA33BD970F64A6301FA75AE2EB22)

​起始位：为低电平；

停止信号：可由0.5、1、1.5、2个逻辑1的数据位表示

位0~位7：有效数据可被约定为 5—8位长

校验位：奇校验；偶校验

#### 2.2.1.4 波特率

​![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796160186/D2B5CA33BD970F64A6301FA75AE2EB22)

 **fPLCK**为usart时钟，USARTDIV是存放在波特率寄存器中的一个无符号定点数。其中 DIV_Mantissa[11:0]位定义USARTDIV 的整数部分，DIV_Fraction[3:0]位定义USARTDIV 的小数部分

我们知道USART1使用APB2总线时钟，最高可达72MHz，其他USART的最高频率为36MHz。我们选取USART1作为实例讲解，即fPLCK=72MHz。为得到 115200bps 的波特率，此时：​

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796183233/D2B5CA33BD970F64A6301FA75AE2EB22)

解得USARTDIV=39.0625，可算得 DIV_Fraction=0.0625*16=1=0x01，DIV_Mantissa=39=0x27，即 应该设置 USART_BRR 的值为 0x271。

#### **2.2.1.5 波特率与比特率的区别**

**波特率**是指单位时间内传送二进制数据的位数，单位用**bps(位/秒)表示，记作波特**。
比如：波特率为9600，则1秒传送9600位，也就是960个字节。
比如在异步串行传输系统中，若字符格式：1位起始位，8位数据位，1个校验位，1个终止位，假设波特率为1200bps。
有效数据位8位，传送一个字符为1+8+1+1=11，比特率为：1200*（8/11）

### 2.2.2 I2C通讯协议总结

#### 2.2.2.1 物理层

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796229292/D2B5CA33BD970F64A6301FA75AE2EB22)

**注意：**
**开漏输出：** 高电平无驱动能力，需要借助外部上拉输出高电平。

因为I2C协议是支持多个主设备与多个从设备在一条总线上的，此时就会有多个GPIO口连接在同一条总线上，就势必会出现输出高、低电平不统一的情况，如果采用推挽输出时，就可能会出现某个GPIO的V~~cc~~和GND连接在一起造成短路的情况，当你采用开漏输出时，因为有上拉电阻的存在就可以避免这一问题的出现。

总线通过上拉电阻接到电源。当I2C设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。

多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。

SDA线在输入时配置成上下拉输入模式。

数据传送过程中，先传送最高位（**MSB）**，每一个被传送的字节后面都必须跟随着**1位应答位**（即一帧共有**9位长**）。

#### 2.2.2.2 协议层

(1) 主机写数据给从机

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796264332/D2B5CA33BD970F64A6301FA75AE2EB22)

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796270902/D2B5CA33BD970F64A6301FA75AE2EB22)

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796277336/D2B5CA33BD970F64A6301FA75AE2EB22)

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796283973/D2B5CA33BD970F64A6301FA75AE2EB22)

这些图表示的是主机和从机通讯时，SDA 线的数据包序列。
其中S表示由主机的 I2C 接口产生的传输起始信号(S)，这时连接到I2C总线上的所有从机都会接收到这个信号。
- 起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号(SLAVE_ADDRESS)。
- 在 I2C 总线上，每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。
-  据 I2C 协议，这个**从机地址可以是7位或10位（7位用的更加广泛）**。**在地址位之后，是传输方向的选择位**：

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796318598/D2B5CA33BD970F64A6301FA75AE2EB22)

该位为0，主机向从机写数据。
该位为1，主机由从机读数据。
从机接收到匹配的地址后，主机或从机会返回一个应答(ACK)或非应答(NACK)信号，只有接收到应答信号后，主机才能继续发送或接收数据。

**注意：**
每次读写数据，数据包为8位，即一个字节。
主机向从机**写**时，主机给从机发送一个字节，从机回复一个应答信号，然后主机再发送一个字节，不断重复这个过程。**当数据传输结束时，主机给从机发送停止信号（P）。**
主机向从机**读**时，从机给主机发送一个字节，主机回复一个应答信号，然后从机再发送一个字节，不断重复这个过程。**当主机不想接收数据时，主机给从机返回一个非应答信号（NACK）。**

(2) 读和写数据：
除了基本的读写，I2C通讯更常用的是复合格式，即第三幅图的情况，该传输过程有两次起始信号(S)。一般在第一次传输中，主机通过SLAVE_ADDRESS寻找到从设备后，发送一段“数据”，这段数据通常用于表示从设备内部的寄存器或存储器地址(注意区分它与 SLAVE_ADDRESS 的区别)；在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。

#### 2.2.2.3 通讯信号电路定义：

**起始信号/终止信号（一般由主机产生）**

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796401666/D2B5CA33BD970F64A6301FA75AE2EB22)

起始信号：SCL高，SDA由高变低

终止信号：SCL高，SDA由低变高

**数据有效性：**

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796423867/D2B5CA33BD970F64A6301FA75AE2EB22)

**响应信号：**

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796443326/D2B5CA33BD970F64A6301FA75AE2EB22)

传输时主机产生时钟，在**第9个时钟**时，数据发送端会释放SDA的控制权，由数据接收端控制SDA，若SDA为高电平，表示非应答信号 (NACK)，低电平表示应答信号(ACK)。

#### 2.2.2.4 硬件I2C和软件I2C的区别

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796484866/D2B5CA33BD970F64A6301FA75AE2EB22)

### 2.2.3 SPI通讯协议总结

#### 2.2.3.1 物理层

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796523632/D2B5CA33BD970F64A6301FA75AE2EB22)

CS线（NSS线）：从设备选择线，也称为片选信号线。哪个NSS线设为低电平，就是选中对应的模块。NSS线为高电平时，为结束信号。
SCK：时钟信号线，用于通讯主机产生，决定了通讯的速率，STM32的SPI时钟频率最大为fPCLK/2，一般通讯过程中，通讯速率受限于低速设备。
MOSI：主机发送，从机接收端口。
MISO：主机接收，从机发送端口。

#### 2.2.3.2 协议层

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796574157/D2B5CA33BD970F64A6301FA75AE2EB22)

起始信号：NSS由高变低       停止信号：NSS由低变高

**注意：**
MOSI与MISO的信号只在NSS为低电平的时候才有效，在SCK的每个时钟周期MOSI和MISO传输一位数据。数据的输入和输出是同时进行的，在**SCK下降沿**进行数据**采样**，SPI每次数据传输可以**以8位或16位为单位**，每次传输单位数不受限制。

#### 2.2.3.3 SPI通讯模式（四种）
四种通讯模式最大的区别：总线空闲时 SCK 的时钟状态以及数据采样时刻。
因此，在此引入“时钟极性CPOL”和“时钟相位CPHA”概念。

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796597587/D2B5CA33BD970F64A6301FA75AE2EB22)

#### 2.2.3.4 控制逻辑

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796624960/D2B5CA33BD970F64A6301FA75AE2EB22)

主模式收发流程及事件说明如下：

(1) 控制NSS信号线，产生起始信号(图中没有画出)；

(2) 把要发送的数据写入到“数据寄存器“DR”中，该数据会被存储到发送缓冲区；

(3) 通讯开始，SCK时钟开始运行。MOSI 把发送缓冲区中的数据一位一位地传输出去；MISO 则把数据一位一位地存储进接收缓冲区中；

(4) 当发送完一帧数据的时候，“**状态寄存器 SR**”中的“TXE 标志位”会被置 1，表示传输完一 帧，发送缓冲区已空；类似地，当接收完一帧数据的时候，“RXNE 标志位”会被置 1，表示传输完一帧，接收缓冲区非空；

(5) 等待到“TXE 标志位”为 1 时，若还要继续发送数据，则再次往“数据寄存器 DR”写入数据 即可；等待到“RXNE 标志位”为 1 时，通过读取“数据寄存器 DR”可以获取接收缓冲区中的 内容。
假如我们使能了 TXE 或 RXNE 中断，TXE 或 RXNE 置 1 时会产生 SPI 中断信号，进入同一个中断服务函数，到 SPI 中断服务程序后，可通过检查寄存器位来了解是哪一个事件，再分别进行处理。也可以使用 DMA 方式来收发“数据寄存器 DR”中的数据。

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796660549/D2B5CA33BD970F64A6301FA75AE2EB22)

### 2.2.4 CAN通讯协议总结

#### 2.2.4.1 物理层

**(1) 闭环网络**

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796687556/D2B5CA33BD970F64A6301FA75AE2EB22)

CAN 物理层的形式主要有两种，图 CAN 闭环总线通讯网络中的 CAN 通讯网络是一种遵循 ISO11898 标准的高速、短距离“闭环网络”，它的总线最大长度为 40m，通信速度最高为 1Mbps，总线的两端各要求有一个“120欧”的电阻。

(2) **开环网络**

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723796722551/D2B5CA33BD970F64A6301FA75AE2EB22)

  图 CAN 开环总线通讯网络 中的是遵循 ISO11519-2 标准的低速、远距离“开环网络”，它的最大传输距离为 1km，最高通讯速率为 125kbps，两根总线是独立的、不形成闭环，要求每根总线上 各串联有一个“2.2千欧”的电阻。
CAN 通讯节点由一个 CAN 控制器及 CAN 收发器组成，控制器与收发器之间通过 CAN_Tx 及 CAN_Rx 信号线相连，收发器与 CAN 总线之间使用 CAN_High 及 CAN_Low 信号线相连。其中 CAN_Tx 及 CAN_Rx 使用普通的类似 TTL 逻辑信号，而 CAN_High 及 CAN_Low 是一对差分信 号线，使用比较特别的差分信号，下一小节再详细说明。

  
  

