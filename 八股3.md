# 3. RTOS

## 3.1 内存管理

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723797307764/D2B5CA33BD970F64A6301FA75AE2EB22)

### 3.1.1 关于heap_1.c
它只实现了 pvPortMalloc，没有实现 vPortFree。 如果你的程序不需要删除内核对象，那么可以使用 heap_1。FreeRTOS 在创建任务时，需要 2 个内核对象：task control block(TCB)、stack。（TCB任务控制块和栈）。

## 3.2 RTOS移植与中断管理

1、修改sys.h文件，让它支持OS。

2、修改usart文件，更改中断。在uC/OS的时候，进入和退出中断需要添加OSIntEnter()和OSIntExit()两个函数，然后在FreeRTOS中并没有该机制，所以将这里的代码删除。

3、关于delay函数的修改，FreeRTOS中使用SysTick作为作为操作系统的心跳，所以需要将xPortSysTickHandler()添加，作为系统始终中断。

4、delay_init() 用于初始化SysTick，主要修改SysTick的重装载值，修改delay_ms和delay_us函数。

5、修改中断（SysTick中断、SVC中断、PendSV中断）。其中SysTick中断在delay.c文件中已经定义。

## 3.3 Systick中断和PendSV中断
在Cortex-M内核上，FreeRTOS使用Systick定时器作为心跳时钟，一般默认心跳时钟为1ms，进入Systick中断后，内核会进入处理模式进行处理，在Systick中断处理中，系统会在 ReadList 就绪链表从高优先级到低优先找需要执行的任务，进行调度，如果有任务的状态发生了变化，改变了状态链表，就会产生一个pendSV异常，进入pendSV异常，通过改变进程栈指针（PSP）切换到不同的任务。

对于相同优先级的任务，每隔一个Systick，运行过的任务被自动排放至该优先级链表的尾部（时间片调度）。

## 3.4 任务管理

vTaskDelay（）为相对延时函数，可以让任务进入阻塞状态。    

空闲任务

FreeRTOS程序在任意时刻，必须**至少有一个任务处于运行状态**，为了达到这个要求，FreeRTOS使用了Idle任务：当vTaskStartScheduler调用后，调度器会自动创建Idle任务，这个任务的任务函数就是一个连续性工作的任务，所以他总是可以处于就绪态（在运行态和就绪态之间转换，没有其他状态）。由于Idle任务的优先级是最低的（优先级为0），所以Idle任务不会抢占用户任务的运行。当其他高优先级的任务需要运行时，他们会抢占Idle任务。

**Idle任务主要用于资源回收清理工作**，例如当你在程序中删除一个任务后，就需要Idle任务去清理这个任务占用的资源。因此，不要让Idle任务“饿死”，具体而言，不要创建一个优先级比Idle任务优先级高，且连续性工作的任务。如果应用程序也需要一个在背后连续工作的任务，则应该设置其优先级和Idle任务相同。当然这个需求更好的实现方法是通过下面介绍的Idle钩子来完成。

# 4. Linux驱动

## 4.1 Linux系统移植流程

## 4.2 程序编译过程

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723797381557/D2B5CA33BD970F64A6301FA75AE2EB22)

# 5. 网络通信

## 5.1 三次握手

1、首先 Client 端发送连接请求报文

2、Server 段接受连接后回复 ACK 报文，并为这次连接分配资源。

3、Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了。

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723797419973/D2B5CA33BD970F64A6301FA75AE2EB22)

## 5.2 四次挥手

1、第一次挥手：Clien发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

2、第二次挥手：Server收到FIN后，发送一个ACK给Client, Server进入CLOSE_WAIT状态。

3、第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

4、第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，发送ACK给Server，Server进入CLOSED状态，完成四次挥手。

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723797551629/D2B5CA33BD970F64A6301FA75AE2EB22)

## 5.3 Linux下TCP的程序构建流程

## 5.4 TCP与UDP的区别

1、TCP面向连接，通过三次握手建立连接，四次挥手接除连接;UDP是无连接的，即发送数据之前不需要建立连接，这种方式为UDP带来了高效的传输效率，但也导致无法确保数据的发送成功。

2、TCP是可靠的通信方式。通过TCP连接传送的数据，TCP通过超时重传、 数据校验等方式来确保数据无差错，不丢失，不重复，且按序到达；而UDP由于无需连接的原因，将会以最大速度进行传输，但不保证可靠交付，也就是会出现丢失、重复等等问题。

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，由于连接的问题，当网络出现波动时，连接可能出现响应问题；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。

4、每一条TCP连接只能是点到点的；而UDP不建立连接，所以可以支持一对一，一对多，多对一和多对多的交互通信，也就是可以同时接受多个人的包。

5、TCP需要建立连接，首部开销20字节相比8个字节的UDP显得比较大。

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

  
---
 # 6. 操作系统

## 6.1 什么是进程？什么是线程？

进程是资源分配的基本单位，它是程序执行时的一个实例，在程序运行时创建。

线程是程序执行的最小单位，是进程的一个执行流，一个进程由多个线程组成的。

协程是一种比线程更加轻量级的存在。一个线程也可以拥有多个协程。其执行过程更类似于子例程，或者说不带返回值的函数调用。

## 6.2 内核线程和用户线程的区别？

1. 内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。

2. 用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。

3. 用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。

4. 在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。

5. 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。

## 6.3 进程和线程有什么区别？

1、根本区别
进程是资源分配的基本单位，线程是程序执行的最小单位

2、资源开销
进程有自己独立地址空间（代码空间和数据空间），每启动一个进程，系统会为它分配地址空间。
线程没有自己独立的地址空间，线程共享进程中的数据，使用相同的地址空间。每个线程都有自己的堆栈。
线程切换的资源开销要比进程小。涉及频繁切换，就选择线程。
线程开销小，但是不利于进行资源包含；进程开销大，但是有利于资源保护。

3、关于通信

线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。（ftok函数）

但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也跟着死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

4、执行过程
每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

## 6.4 何时使用多进程，何时使用多线程？
对资源的管理和保护要求高，不限制开销和效率时，使用多进程。
要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。

## 6.5 进程的几种状态？

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723797965792/D2B5CA33BD970F64A6301FA75AE2EB22)

​关于IO：
用户程序进行IO的读写，会用到read&write两大系统调用。read系统调用，是把数据从**内核缓冲区**复制到**进程缓冲区**；而write系统调用，是把数据从**进程缓冲区**复制到**内核缓冲区**
 **同步IO**
是指用户空间线程是主动发起IO请求的一方，内核空间是被动接受方。
**异步IO**
是指内核kernel是主动发起IO请求的一方，用户线程是被动接受方。
## 6.6 进程创建的方式？

### 6.6.1 使用fork创建
创建新进程在Linux的下是由父进程来完成的，创建完成的新进程是子进程。
新进程的地址空间有两种可能性：
1、子进程是父进程的复制品（除了PID和task_struct是子进程自己的，其余的都从父进程复制而来
2、子进程装入另一个程序。
在Linux下的fork函数用于创建一个新的进程，使用fork函数来创建一个进程时，子进程只是完全复制父进程的资源。​

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723797997921/D2B5CA33BD970F64A6301FA75AE2EB22)

### 6.6.2 fork和vfork的区别？
void exit( int status) 结束当前进程并将status返回；exit结束进程会刷新缓冲区
void exit(int status)  这个不会进行缓冲区刷新

1. fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段

2. fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。

3. vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。

4. 当需要改变共享数据段中变量的值，则拷贝父进程。

## 6.7 进程间通信方式有哪些？有什么优缺点？

### 6.7.1 管道(pipe)
管道这种通讯方式有两种限制：
一是**半双工的通信**，数据只能单向流动；
二是**只能在具有亲缘关系的进程间使用**。进程的亲缘关系通常是指父子进程关系。
缺点：速度慢，容量有限，只有父子进程能通讯。
### 6.7.2 流管道 s_pipe
可以进行双向传输（全双工）;允许具有亲缘关系进程间通信；也允许无亲缘关系进程间通信。
### 6.7.3 信号量
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

 缺点：只能用来同步，不能用来进行传递复杂信息。

### 6.7.4 消息队列

容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题，消息队列可以不再局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息 发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便， 但是信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合。此种方法不太常用。

### 6.7.5 共享内存

利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。共享内存块提供了在任意数量的 进程之间进行高效双向通信的机制。每个使用者都可以读取写入数据，但是所有程序之间必须达成并遵 守一定的协议，以防止诸如在读取信息之前覆写内存空间等竞争状态的出现。

## 6.8 线程创建方式

![](https://uploadfiles.nowcoder.com/images/20240816/732217308_1723798071903/D2B5CA33BD970F64A6301FA75AE2EB22)

## 6.9 僵尸进程、孤儿进程、守护进程是什么？
**僵尸进程：** 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
**孤儿进程：** 父进程异常结束，子进程被进程Init所收养。
**守护进程：** 创建守护进程时，有意把父进程结束，然后被1号进程init收养
**区分：** 一个正常运行的子进程，如果此刻子进程退出，父进程没有及时调用wait或waitpid收回子进程的系统资源，该进程就是僵尸进程，如果系统收回了，就是正常退出，如果一个正常运行的子进程，父进程退出了但是子进程还在，该进程此刻是孤儿进程，被init收养，如果父进程是故意被杀掉，子进程做相应处理后就是守护进程

## 6.10 僵尸进程的危害？
在进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息(包括进程号PID，退出状态，运行时间等)。直到父进程通过wait / waitpid 来取时才释放。 如果进程不调用 wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。

## 6.11 如何清理僵尸进程？
当系统中出现了僵尸进程时，我们是无法通过 kill 命令把它清除掉的。但是我们可以杀死它的父进程， 让它变成孤儿进程，并进一步被系统中管理孤儿进程的进程收养并清理。  

  
  